{% extends "base.html" %}

{% block style %}
.home
{
    fill: rgba({{ color_home_primary }},1.0);
    stroke: rgba(0,0,0,1.0);
}
.home.finishedAction
{
    fill: rgba({{ color_home_primary }},0.5);
}
.away
{
    fill: rgba({{ color_away_primary }},1.0);
    stroke: rgba(0,0,0,1.0);
}
.away.finishedAction
{
    fill: rgba({{ color_away_primary }},0.5);
}
text.home
{
    stroke: none;
}
text.away
{
    stroke: none;
}
.playerNumber
{
    text-anchor: middle;
    dominant-baseline: middle;
    stroke: none;
}
.home .playerNumber
{
    fill: rgba({{ color_home_secondary }},1.0);
}
.away .playerNumber
{
    fill: rgba({{ color_away_secondary }},1.0);
}
.selected.player .playerSymbol
{
    stroke: #000000;
    stroke-width: 4;
}
.highlightBlock .playerSymbol
{
    stroke: darkred;
    stroke-width: 4;
}
.highlightPass .playerSymbol
{
    stroke: skyblue;
    stroke-width: 4;
}
.pitch
{
    fill: #DDFFDD;
    stroke: #BBFFBB;
    stroke-width: 1;
}
.pitch .gridOption
{
    stroke: #FF0000;
    stroke-width: 4;
}
.pitch .highlightMove
{
    stroke: darkgreen;
    stroke-width: 4;
}
.pitch .highlightDodge
{
    stroke: darkred;
    stroke-width: 4;
}
.pitch .highlightGoForIt
{
    stroke-dasharray: 5,5;
}
.pitch .highlightPass
{
    stroke: skyblue;
    stroke-width: 4;
}
.mainBorder
{
    stroke: tan;
    stroke-width: 3;
}
.secondaryBorder
{
    stroke: tan;
    stroke-width: 3;
    stroke-dasharray: 9,9;
}
.bench
{
    fill: tan;
    stroke: saddlebrown;
    stroke-width: 2;
}
.benchText
{
    fill: saddlebrown;
    text-anchor: middle;
    dominant-baseline: middle;
}
.button
{
    fill: #00BB00;
    stroke: #008800;
    stroke-width: 1;
}
.buttonText
{
    fill: #000000;
    text-anchor: middle;
    dominant-baseline: middle;
}
.selected .button
{
    stroke: #000000;
    stroke-width: 4;
}
.inactive .button
{
    fill: #AAAAAA;
}
.inactive .buttonText
{
    fill: #444444;
}
.rerollUsed
{
    fill: #AAAAAA;
}
#optionsWindow
{
    fill: antiquewhite;
    stroke: black;
    stroke-width: 2;
}
#optionsHtml
{
    text-align: center;
}
.knockDownSymbol
{
    stroke: black;
    stroke-width: 1;
    fill: yellow;
}
.stunnedSymbol
{
    stroke: black;
    stroke-width: 1;
    fill: red;
}
.ball
{
    stroke: black;
    stroke-width: 1;
    fill: brown;
}
.infoBox .background
{
    stroke: black;
    stroke-width: 2;
    fill: antiquewhite;
}
{% endblock style %}

{% block content %}
<script type="text/javascript" src="/static/js/d3.v3.min.js"></script>
<script type="text/javascript" src="/static/js/jquery-1.10.2.js"></script>
<script type="text/javascript" src="/static/js/symbols.js"></script>
<script type="text/javascript">
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
var csrftoken = getCookie('csrftoken');
function csrfSafeMethod(method) {
    // these HTTP methods do not require CSRF protection
    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}
$.ajaxSetup({
    crossDomain: false, // obviates need for sameOrigin test
    beforeSend: function(xhr, settings) {
        if (!csrfSafeMethod(settings.type)) {
            xhr.setRequestHeader("X-CSRFToken", csrftoken);
        }
    }
});

var playerId = function(d) {
    return d.side + d.num;
}

var gridId = function(d) {
    return "grid" + d.xpos + "_" + d.ypos;
}

var cx = function(d) {
    return viewData.squareSize * (0.5 + d.xpos) + viewData.margin;
}
var cy = function(d) {
    return viewData.squareSize * (0.5 + d.ypos) + viewData.margin;
}

var cxBall = function() {
    return viewData.squareSize * (0.7 + matchData.xBall) + viewData.margin;
}
var cyBall = function() {
    return viewData.squareSize * (0.7 + matchData.yBall) + viewData.margin;
}

var nSquaresX = 26,
    nSquaresY = 15;

var viewData = {
    margin: 10,
    squareSize: 40,
    buttonWidth: 120,
    buttonHeight: 30,
    infoWidth: 200,
    lineHeight: 20,
    activityType: "normal",
    scale: 1.0,
    scaleFactor: 1.1
};
viewData.buttonX = viewData.margin;
viewData.infoX = viewData.buttonX + viewData.buttonWidth + viewData.margin;
viewData.infoHeight = 0.5*(nSquaresY * viewData.squareSize - viewData.margin);
viewData.playerSize = 0.95 * viewData.squareSize;
viewData.rightPanelWidth = viewData.buttonWidth + viewData.infoWidth + 3*viewData.margin;
viewData.bottomPanelHeight = 120;
viewData.width = nSquaresX*viewData.squareSize + 2*viewData.margin;
viewData.height = nSquaresY*viewData.squareSize + 2*viewData.margin;
viewData.top = $("#banner").height() + 2*viewData.margin;

var selected = null;

var players = {{ players_json | safe }};
var matchData = {{ match_data | safe }};
var history = {{ history | safe }};
var username = "{{ username }}";

var stepStack = new Array;

var addStepToStack = function(step) {
    if (step != null) {
        stepStack[stepStack.length] = step;
        if (stepStack.length == 1) {
            processNextStep();
        }
    }
}

var playersOnPitch = function() {
    var onPitch = new Array;
    for (var index = 0; index < players.length; index++) {
        if (players[index].onPitch) {
            onPitch[onPitch.length] = players[index];
        }
    }
    return onPitch;
}

var playerInPos = function(xpos, ypos) {
    for (var playerIndex = 0; playerIndex < players.length; playerIndex++) {
        if (players[playerIndex].xpos == xpos &&
            players[playerIndex].ypos == ypos &&
            players[playerIndex].onPitch) {
            return players[playerIndex];
        }
    }
    return null;
}

var playerWithId = function(id) {
    var side = id.substring(0, 4);
    var num = id.substring(4);
    return findPlayer(side, num);
}

var findPlayer = function(side, num) {
    for (var index = 0; index < players.length; index++) {
        var player = players[index];
        if (player.side == side && player.num == num) {
            return player;
        }
    }
    return null;
}

var ballInPos = function(xpos, ypos) {
    return (matchData.xBall == xpos && matchData.yBall == ypos);
}

var knockDownSymbolGenerator = function(xpos, ypos, stunned) {
    var nPoint = 10;
    var outerRadius = 0.2 * viewData.squareSize;
    if (stunned) {
        outerRadius *= 1.5;
    }
    var innerRadius = 0.6 * outerRadius;
    var jitter = 0.08 * outerRadius;
    var x0 = viewData.margin + viewData.squareSize*(xpos + 0.25);
    var y0 = viewData.margin + viewData.squareSize*(ypos + 0.25);
    var coords = new Array(2*nPoint + 1);
    var theta;
    for (var iPoint = 0; iPoint < nPoint; iPoint++) {
        theta = 2 * Math.PI * iPoint / nPoint;
        coords[2*iPoint] = {
            "x": x0 + outerRadius*Math.cos(theta) + 2*jitter*(Math.random()-0.5),
            "y": y0 + outerRadius*Math.sin(theta) + 2*jitter*(Math.random()-0.5)
        }
        theta = 2 * Math.PI * (iPoint + 0.5) / nPoint;
        coords[2*iPoint + 1] = {
            "x": x0 + innerRadius*Math.cos(theta) + 2*jitter*(Math.random()-0.5),
            "y": y0 + innerRadius*Math.sin(theta) + 2*jitter*(Math.random()-0.5)
        }
    }
    coords[2*nPoint] = {"x": coords[0].x, "y": coords[0].y};
    return coords;
}

var createKnockDownSymbol = function(xpos, ypos, stunned) {
    var player = playerInPos(xpos, ypos);
    var id, symbolClass;
    if (stunned) {
        id = playerId(player) + "stunned";
        symbolClass = "stunnedSymbol"
    } else {
        id = playerId(player) + "knockDown";
        symbolClass = "knockDownSymbol"
    }
    var line = d3.svg.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .interpolate("linear");
    var symbol = d3.select("#"+playerId(player)).append("path")
        .attr("class", symbolClass)
        .attr("id", id)
        .data([knockDownSymbolGenerator(xpos, ypos, stunned)])
        .attr("d", line);
    return symbol;
}

var moveLine = function(id, deltaX, deltaY) {
    var path = d3.select("#"+id);
    var data = path.data()[0];
    for (var i = 0; i < data.length; i++) {
        data[i].x += deltaX;
        data[i].y += deltaY;
    }
    var line = d3.svg.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .interpolate("linear");
    path.transition().attr("d", line);
}

var standUp = function() {
    if (!(d3.select("#standUpButton").classed("inactive"))) {
        var step = {
            "stepType": "standUp",
            "action": selectedAction,
            "side": selected.side,
            "num": selected.num
        }
        addStepToStack(step);
        d3.select("#standUpButton").classed("inactive", true);
    }
}

var defineButtonData = function(turnType) {
    var buttonData;
    if (turnType == "normal") {
        buttonData = [
            {label: "End Turn",
             data: null,
             func: endTurn,
             cl: "",
             id: "endTurnButton",
             group: 0},
            {label: "Move",
             data: {action: "move", singular: false},
             func: selectAction,
             cl: "action",
             id: "moveButton",
             group: 1},
            {label: "Block",
             data: {action: "block", singular: false},
             func: selectAction,
             cl: "action",
             id: "blockButton",
             group: 1},
            {label: "Blitz",
             data: {action: "blitz", singular: true},
             func: selectAction,
             cl: "action",
             id: "blitzButton",
             group: 1},
            {label: "Pass",
             data: {action: "pass", singular: true},
             func: selectAction,
             cl: "action",
             id: "passButton",
             group: 1},
            {label: "Hand-off",
             data: {action: "handOff", singular: true},
             func: selectAction,
             cl: "action",
             id: "handOffButton",
             group: 1},
            {label: "Foul",
             data: {action: "foul", singular: true},
             func: selectAction,
             cl: "action",
             id: "foulButton",
             group: 1}
        ];
    } else if (turnType == "placeBall") {
        buttonData = [
            {label: "Submit",
             data: {},
             func: submitBallPosition,
             cl: "",
             id: "submitButton",
             group: 0}
        ];
    } else if (turnType == "placePlayers") {
        buttonData = [
            {label: "Submit",
             data: {},
             func: submitPlayerPosition,
             cl: "",
             id: "submitButton",
             group: 0}
        ];
    } else if (turnType == "touchback") {
        buttonData = [
            {label: "Submit",
             data: {},
             func: submitTouchback,
             cl: "",
             id: "submitButton",
             group: 0}
        ];
    } else if (turnType == "end") {
        buttonData = [];
    }
    return buttonData;
}

var refreshButtonColumn = function() {
    svgRight.selectAll("g.buttonColumn").data([]).exit().remove();
    var g = svgRight.selectAll("g.buttonColumn").data(viewData.buttonData);
    var newButton = g.enter()
        .append("g")
        .attr("class", function(d) {return d.cl;})
        .attr("id", function(d) {return d.id;})
        .classed("buttonColumn", true)
    newButton.append("rect")
        .attr("x", viewData.buttonX)
        .attr("y", function(d, i) {return (1+i+2*d.group)*viewData.margin + i*viewData.buttonHeight;})
        .attr("width", viewData.buttonWidth)
        .attr("height", viewData.buttonHeight)
        .classed("button", true)
        .on("click", function(d) {d.func(d.data);})
    newButton.append("text")
        .attr("x", viewData.buttonX + 0.5*viewData.buttonWidth)
        .attr("y", function(d, i) {return (1+i+2*d.group)*viewData.margin + (i+0.5)*viewData.buttonHeight;})
        .classed("buttonText", true)
        .text(function(d) {return d.label;})
        .on("click", function(d) {d.func(d.data);});
    g.exit().remove();
}

var addButtonToColumn = function(buttonData) {
    viewData.buttonData[viewData.buttonData.length] = buttonData;
    refreshButtonColumn();
}

var removeButtonFromColumn = function(id) {
    for (var i = 0; i < viewData.buttonData.length; i++) {
        if (viewData.buttonData[i].id == id) {
            viewData.buttonData.splice(i, 1);
            break;
        }
    }
    refreshButtonColumn();
}

var highlightStep = function(d) {
    pitch.classed("highlightMove", false)
        .classed("highlightDodge", false)
        .classed("highlightGoForIt", false)
        .classed("highlightPass", false);
    d3.selectAll(".player").classed("highlightBlock", false)
        .classed("highlightPass", false);
    var stepArray = defineStep(d.xpos, d.ypos);
    if (stepArray.length != 0) {
        var step = stepArray[stepArray.length - 1];
        if (step.stepType == "move" || step.stepType == "placeBall" || step.stepType == "placePlayer") {
            var pitchSquare = d3.select("#"+gridId(d));
            if (step.dodge) {
                pitchSquare.classed("highlightDodge", true);
            } else {
                pitchSquare.classed("highlightMove", true);
            }
            if (stepArray[0].stepType == "goForIt") {
                pitchSquare.classed("highlightGoForIt", true);
            }
            pitch.sort(function(a, b){return (a == d) ? 1 : -1});
        } else if (step.stepType == "block" || step.stepType == "foul") {
            var player = d3.select("#"+playerId(playerInPos(d.xpos, d.ypos)));
            player.classed("highlightBlock", true);
        } else if (step.stepType == "pass" || step.stepType == "handOff") {
            var playerData = playerInPos(d.xpos, d.ypos);
            if (playerData == null) {
                var pitchSquare = d3.select("#"+gridId(d));
                pitchSquare.classed("highlightPass", true);
                pitch.sort(function(a, b){return (a == d) ? 1 : -1});
            } else {
                var player = d3.select("#"+playerId(playerData));
                player.classed("highlightPass", true);
            }
        }
    }
}

// Make the overall layout of the page
divPitch = d3.select("body").append("div")
    .attr("style", "position:absolute; left:0px; right:"+viewData.rightPanelWidth+"px; top:"+viewData.top+"px; bottom:"+viewData.bottomPanelHeight+"px; overflow:auto;")
    .attr("id", "divPitch");
divRight = d3.select("body").append("div")
    .attr("style", "position:absolute; right:0px; width:"+viewData.rightPanelWidth+"px; top:"+viewData.top+"px; bottom:0px; overflow:hidden;")
    .attr("id", "divRight");
divBottom = d3.select("body").append("div")
    .attr("style", "position:absolute; left:0px; right:"+viewData.rightPanelWidth+"px; bottom:0px; height:"+viewData.bottomPanelHeight+"px; overflow:hidden;")
    .attr("id", "divBottom");

// Make the SVG containers
var svgPitch = divPitch.append("svg")
    .attr("width", viewData.width)
    .attr("height", viewData.height);
var gPitch = svgPitch.append("g");
var svgRight = divRight.append("svg")
    .attr("width", $("#divRight").width())
    .attr("height", 2*viewData.infoHeight+3*viewData.margin);
var svgBottom = divBottom.append("svg")
    .attr("width", viewData.width)
    .attr("height", $("#divBottom").height());

// Functions for zooming in and out
var setZoom = function(scale) {
    viewData.scale = scale;
    gPitch.transition().attr("transform", "scale("+scale+")");
    svgPitch.transition().attr("width", viewData.width*scale).attr("height", viewData.height*scale);
}
var zoomIn = function() {
    setZoom(viewData.scale * viewData.scaleFactor);
}
var zoomOut = function() {
    setZoom(viewData.scale / viewData.scaleFactor);
}

// Make the pitch
var clickPitch = function(d) {
    if (stepStack.length == 0) {
        var stepArray = defineStep(d.xpos, d.ypos);
        for (var i =0; i < stepArray.length; i++) {
            addStepToStack(stepArray[i]);
        }
    }
}

var drawPitch = function() {
    var coords = new Array(nSquaresX * nSquaresY);
    for (var xIndex = 0; xIndex < nSquaresX; xIndex++) {
        for (var yIndex = 0; yIndex < nSquaresY; yIndex++) {
            coords[yIndex*nSquaresX + xIndex] = {"xpos": xIndex, "ypos": yIndex};
        }
    }
    var pitch = gPitch.append("g").attr("class", "pitch")
        .selectAll("rect.pitch").data(coords).enter().append("rect")
        .attr("x", function(d) { return d.xpos*viewData.squareSize + viewData.margin; })
        .attr("y", function(d) { return d.ypos*viewData.squareSize + viewData.margin; })
        .attr("width", viewData.squareSize)
        .attr("height", viewData.squareSize)
        .attr("id", gridId)
    var line = d3.svg.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .interpolate("linear");
    var top = viewData.margin;
    var bottom = top + nSquaresY*viewData.squareSize;
    var left = viewData.margin;
    var right = left + nSquaresX*viewData.squareSize;
    var centre = 0.5 * (left + right);
    var endLeft = left + viewData.squareSize;
    var endRight = right - viewData.squareSize;
    var wideTop = top + 4*viewData.squareSize;
    var wideBottom = bottom - 4*viewData.squareSize;
    var mainBorderData = [
        [{x: left, y: top}, {x: right, y: top}],
        [{x: right, y: top}, {x: right, y: bottom}],
        [{x: right, y: bottom}, {x: left, y: bottom}],
        [{x: left, y: bottom}, {x: left, y: top}],
        [{x: endLeft, y: top}, {x: endLeft, y: bottom}],
        [{x: centre, y: top}, {x: centre, y: bottom}],
        [{x: endRight, y: top}, {x: endRight, y: bottom}]
    ];
    var secondaryBorderData = [
        [{x: endLeft, y: wideTop}, {x: endRight, y: wideTop}],
        [{x: endLeft, y: wideBottom}, {x: endRight, y: wideBottom}]
    ];
    gPitch.selectAll("path.mainBorder")
        .data(mainBorderData)
        .enter()
        .append("path")
        .attr("class", "mainBorder")
        .attr("d", line);
    gPitch.selectAll("path.secondaryBorder")
        .data(secondaryBorderData)
        .enter()
        .append("path")
        .attr("class", "secondaryBorder")
        .attr("d", line);
    return pitch;    
}
var pitch = drawPitch();
pitch.on("click", clickPitch)
pitch.on("mouseover", highlightStep)

var zoomButtonData = [
    {label: "+", func: zoomIn},
    {label: "-", func: zoomOut}
]
var zoomButtonY = function(d, i) {return 1.5*viewData.margin + i*(viewData.buttonHeight+viewData.margin) + $("#divPitch").scrollTop()};
var zoomButtonTextY = function(d, i) {return zoomButtonY(d, i) + 0.5*viewData.buttonHeight};
var zoomButtonX = function() {return 1.5*viewData.margin + $("#divPitch").scrollLeft()};
var zoomButtonTextX = function() {return zoomButtonX() + 0.5*viewData.buttonHeight};
var gZoomButton = svgPitch.selectAll("g.zoom")
    .data(zoomButtonData)
    .enter()
    .append("g")
    .attr("class", "zoom")
    .on("click", function(d) {d.func();});
var zoomButtonRect = gZoomButton.append("rect")
    .attr("x", zoomButtonX)
    .attr("y", zoomButtonY)
    .attr("width", viewData.buttonHeight)
    .attr("height", viewData.buttonHeight)
    .classed("button", true)
var zoomButtonText = gZoomButton.append("text")
    .text(function(d) {return d.label;})
    .attr("x", zoomButtonTextX)
    .attr("y", zoomButtonTextY)
    .classed("buttonText", true)
$("#divPitch").on("scroll", function(){zoomButtonRect.attr("x", zoomButtonX).attr("y", zoomButtonY); zoomButtonText.attr("x", zoomButtonTextX).attr("y", zoomButtonTextY)})

// Make info screens
var drawInfoBox = function(parent, id, y) {
    var infoBox = parent.append("g")
        .attr("class", "infoBox")
        .attr("id", id)
    infoBox.append("rect")
        .attr("x", viewData.infoX)
        .attr("y", y)
        .attr("width", viewData.infoWidth)
        .attr("height", viewData.infoHeight)
        .classed("background", true)
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + viewData.lineHeight)
        .text("")
        .attr("id", id + "Name")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 2*viewData.lineHeight)
        .text("")
        .attr("id", id + "Team")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 3*viewData.lineHeight)
        .text("")
        .attr("id", id + "Position")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 4*viewData.lineHeight)
        .text("MA: ")
        .attr("id", id + "MA")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin + 0.5*viewData.infoWidth)
        .attr("y", y + viewData.margin + 4*viewData.lineHeight)
        .text("ST: ")
        .attr("id", id + "ST")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 5*viewData.lineHeight)
        .text("AG: ")
        .attr("id", id + "AG")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin + 0.5*viewData.infoWidth)
        .attr("y", y + viewData.margin + 5*viewData.lineHeight)
        .text("AV: ")
        .attr("id", id + "AV")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 6*viewData.lineHeight)
        .text("Moves left: ")
        .attr("id", id + "MoveLeft")
    infoBox.append("text")
        .attr("x", viewData.infoX + viewData.margin)
        .attr("y", y + viewData.margin + 7*viewData.lineHeight)
        .text("Skills:")
    for (var i = 0; i < 6; i++) {
        infoBox.append("text")
            .attr("x", viewData.infoX + 2*viewData.margin)
            .attr("y", y + viewData.margin + (8+i)*viewData.lineHeight)
            .text("")
            .attr("id", id + "Skill" + i)
    }
}

var updateInfoBox = function(infoBoxId, player) {
    if (player == null) {
        d3.select("#"+infoBoxId+"Name").text("");
        d3.select("#"+infoBoxId+"Team").text("");
        d3.select("#"+infoBoxId+"Position").text("");
        d3.select("#"+infoBoxId+"MA").text("MA: ");
        d3.select("#"+infoBoxId+"ST").text("ST: ");
        d3.select("#"+infoBoxId+"AG").text("AG: ");
        d3.select("#"+infoBoxId+"AV").text("AV: ");
        d3.select("#"+infoBoxId+"MoveLeft").text("Moves left: ");
        for (var i = 0; i < 6; i++) {
            d3.select("#"+infoBoxId+"Skill"+i).text("");
        }
    } else {
        d3.select("#"+infoBoxId+"Name").text(player.name);
        d3.select("#"+infoBoxId+"Team").text(matchData[player.side+"Team"]);
        d3.select("#"+infoBoxId+"Position").text(player.num+" "+player.position);
        d3.select("#"+infoBoxId+"MA").text("MA: "+player.ma);
        d3.select("#"+infoBoxId+"ST").text("ST: "+player.st);
        d3.select("#"+infoBoxId+"AG").text("AG: "+player.ag);
        d3.select("#"+infoBoxId+"AV").text("AV: "+player.av);
        d3.select("#"+infoBoxId+"MoveLeft").text("Moves left: "+player.moveLeft);
        for (var i = 0; i < player.skills.length && i < 6; i++) {
            d3.select("#"+infoBoxId+"Skill"+i).text(player.skills[i]);
        }
        for (var i = player.skills.length; i < 6; i++) {
            d3.select("#"+infoBoxId+"Skill"+i).text("");
        }
    }
}

drawInfoBox(svgRight, "infoBoxSelected", viewData.margin);
drawInfoBox(svgRight, "infoBoxHighlighted", 2*viewData.margin+viewData.infoHeight);

// Print the team names and current score
gMatchInfo = svgBottom.append("g")
gMatchInfo.append("text")
    .attr("x", viewData.margin+11.5*viewData.squareSize)
    .attr("y", viewData.lineHeight)
    .attr("text-anchor", "end")
    .text(matchData.homeTeam)
    .attr("class", "home")
    .attr("id", "homeTeam")
gMatchInfo.append("text")
    .attr("x", viewData.margin+14.5*viewData.squareSize)
    .attr("y", viewData.lineHeight)
    .text(matchData.awayTeam)
    .attr("class", "away")
    .attr("id", "awayTeam")
gMatchInfo.append("text")
    .attr("x", viewData.margin+11.5*viewData.squareSize)
    .attr("y", 2*viewData.lineHeight)
    .attr("text-anchor", "end")
    .text("Re-rolls: " + matchData.homeRerolls)
    .attr("class", (matchData.homeRerolls > 0) ? "home" : "rerollUsed")
    .attr("id", "homeRerolls")
gMatchInfo.append("text")
    .attr("x", viewData.margin+14.5*viewData.squareSize)
    .attr("y", 2*viewData.lineHeight)
    .text("Re-rolls: " + matchData.awayRerolls)
    .attr("class", (matchData.awayRerolls > 0) ? "away" : "rerollUsed")
    .attr("id", "awayRerolls")
gMatchInfo.append("text")
    .attr("x", 13*viewData.squareSize)
    .attr("y", 1.5*viewData.squareSize)
    .attr("text-anchor", "end")
    .attr("font-size", 1.5*viewData.squareSize)
    .text(matchData.homeScore)
    .attr("class", "home")
    .attr("id", "homeScore")
gMatchInfo.append("text")
    .attr("x", 2*viewData.margin+13*viewData.squareSize)
    .attr("y", 1.5*viewData.squareSize)
    .attr("font-size", 1.5*viewData.squareSize)
    .text(matchData.awayScore)
    .attr("class", "away")
    .attr("id", "awayScore")
gMatchInfo.append("text")
    .attr("x", viewData.margin+13*viewData.squareSize)
    .attr("y", 1.5*viewData.squareSize+viewData.lineHeight)
    .attr("text-anchor", "middle")
    .text("Turn " + matchData.turnNumber)
    .attr("class", matchData.currentSide)
    .attr("id", "turnIndicator")

var clickSubs = function(side) {
    if (currentCoach() != username) {
        return;
    }
    if (matchData.turnType == "placePlayers" && matchData.currentSide == side && selected != null && selected.onPitch) {
        var step = {
            side: side,
            num: selected.num,
            subs: true,
            action: "placePlayers",
            stepType: "placePlayer"
        }
        addStepToStack(step);
    }
}

var benchWidth = function(side, box) {
    var totalWidth = Math.min($("#divBottom").width(), svgBottom.attr("width"));
    if (box == "subs") {
        return 0.5*totalWidth - ($("#"+side+"Team").width()+1.5*viewData.squareSize+2*viewData.margin);
    } else {
        return (0.5*totalWidth - (1.5*viewData.squareSize + viewData.margin)) / 3;
    }
}
var benchHeight = function(side, box) {
    return 0.5*$("#divBottom").height() - viewData.margin;
}
var benchLeft = function(side, box) {
    var totalWidth = Math.min($("#divBottom").width(), svgBottom.attr("width"));
    if (side == "home") {
        if (box == "subs" || box == "knockedOut") {
            return viewData.margin;
        } else if (box == "casualty") {
            return viewData.margin + benchWidth("home", "knockedOut");
        } else {
            return viewData.margin + 2*benchWidth("home", "knockedOut");
        }
    } else {
        if (box == "subs") {
            return 0.5*totalWidth + 1.5*viewData.squareSize + $("#"+side+"Team").width() + viewData.margin;
        } else if (box == "sentOff") {
            return 0.5*totalWidth + 1.5*viewData.squareSize;
        } else if (box == "casualty") {
            return 0.5*totalWidth + 1.5*viewData.squareSize + benchWidth("away", "sentOff");
        } else {
            return 0.5*totalWidth + 1.5*viewData.squareSize + 2*benchWidth("away", "sentOff");
        }
    }
}
var benchTop = function(side, box) {
    if (box == "subs") {
        return viewData.margin;
    } else {
        return viewData.margin + benchHeight(side, box);
    }
}
var drawBenchBox = function(side, box, label) {
    var id = side + box.charAt(0).toUpperCase() + box.slice(1);
    var gBox = gBench.append("g");
    if (box == "subs") {
        gBox.on("click", function(){clickSubs(side);});
    }
    gBox.append("rect")
        .attr("x", benchLeft(side, box))
        .attr("y", benchTop(side, box))
        .attr("width", benchWidth(side, box))
        .attr("height", benchHeight(side, box))
        .attr("class", "bench")
        .attr("id", id);
    gBox.append("text")
        .attr("x", benchLeft(side, box) + 0.5*benchWidth(side, box))
        .attr("y", benchTop(side, box) + 0.5*benchHeight(side, box))
        .text(label)
        .attr("class", "benchText")
        .attr("id", id+"Text");    
}
var gBench = svgBottom.append("g");
var benchSides = ["home", "away"];
var benchBoxes = ["subs", "knockedOut", "casualty", "sentOff"];
var benchLabels = ["Substitutions", "KO'd", "Casualties", "Sent off"];
for (var i = 0; i < benchSides.length; i++) {
    var side = benchSides[i];
    for (var j = 0; j < benchBoxes.length; j++) {
        var box = benchBoxes[j];
        var label = benchLabels[j];
        drawBenchBox(side, box, label);
    }
}

var updateBenchSize = function() {
for (var i = 0; i < benchSides.length; i++) {
    var side = benchSides[i];
    for (var j = 0; j < benchBoxes.length; j++) {
        var box = benchBoxes[j];
            var id = side + box.charAt(0).toUpperCase() + box.slice(1);
            svgBottom.select("#"+id)
                .attr("x", benchLeft(side, box))
                .attr("y", benchTop(side, box))
                .attr("width", benchWidth(side, box))
                .attr("height", benchHeight(side, box));
            svgBottom.select("#"+id+"Text")
                .attr("x", benchLeft(side, box) + 0.5*benchWidth(side, box))
                .attr("y", benchTop(side, box) + 0.5*benchHeight(side, box));
        }
    }    
}
var moveMatchInfo = function() {
    gMatchInfo.attr("transform", "translate("+Math.min(0.5*($("#divBottom").width()-svgBottom.attr("width")), 0)+",0)");
}
moveMatchInfo()
var updateSvgBottom = function() {
    moveMatchInfo();
    updateBenchSize();
}
d3.select(window).on("resize", updateSvgBottom)

var updateTurnIndicator = function() {
    var turnIndicator = d3.select("#turnIndicator");
    if (matchData.turnType == "normal") {
        turnIndicator.text("Turn " + matchData.turnNumber);
    } else if (matchData.turnType == "placePlayers") {
        turnIndicator.text("Place players");
    } else if (matchData.turnType == "placeBall") {
        turnIndicator.text("Place ball");
    } else if (matchData.turnType == "touchback") {
        turnIndicator.text("Touchback");
    } else if (matchData.turnType == "end") {
        turnIndicator.text("End of match")
    }
    if (matchData.turnType == "end") {
        // Colour by whoever won
        if (matchData.homeScore > matchData.awayScore) {
            turnIndicator.attr("class", "home");
        } else if (matchData.awayScore > matchData.homeScore) {
            turnIndicator.attr("class", "away");
        } else {
            turnIndicator.attr("class", "");
        }
    } else {
        turnIndicator.attr("class", matchData.currentSide);
    }
}

updateTurnIndicator();

// Make the control buttons
// End Turn
var endTurn = function(d) {
    var step = {
        "stepType": "endTurn",
        "action": "endTurn",
        "oldSide": matchData.currentSide,
        "turnover": false
    }
    addStepToStack(step);
}

// Action selectors
var selectedAction = null;
var selectAction = function(d) {
    var thisButton = d3.select("#" + d.action + "Button");
    if (!thisButton.classed("inactive") && selected != null) {
        selectedAction = d.action;
        d3.selectAll(".action").classed("selected", false);
        thisButton.classed("selected", true);
        d3.select("#standUpButton").classed("inactive", d.action == "block" || selected.stunned || !(selected.down));
    }
}

var finishLastAction = function() {
    var player = lastActivePlayer();
    if (player != null) {
        finishAction(player);
    }
}

var setAction = function(player, action) {
    if (matchData.turnType == "placeBall" || matchData.turnType == "placePlayers") {
        return;
    }
    if (player != null) {
        player.action = action;
        finishLastAction();
    }
    if (action == "") {
        selectedAction = null;
        svgRight.selectAll("g.action").classed("inactive", function(d){return (d.data.singular && usedActionThisTurn(d.data.action));}).classed("selected", false);
    } else {
        selectedAction = action;
        svgRight.selectAll("g.action").classed("inactive", true).classed("selected", false);
        svgRight.select("#" + action + "Button").classed("inactive", false).classed("selected", true);
    }
    return;
}

var finishAction = function(player) {
    player.finishedAction = true;
    player.moveLeft = 0;
    gPitch.select("#" + playerId(player)).classed("finishedAction", true);
    if (player == selected) {
        updateInfoBox("infoBoxSelected", player);
    }
}

var clickPlayer = function(player) {
    if (currentCoach() != username) {
        return;
    }
    if (viewData.activityType != "normal" || (matchData.turnType != "placePlayers" && !player.onPitch) || (matchData.turnType == "placePlayers" && (player.knockedOut || player.casualty || player.sentOff))) {return;}
    if (selected == player) {
        // Was already selected. Unselect.
        clearSelection()
    } else {
        var stepArray = [];
        if (player.onPitch && (selected != null || matchData.turnType == "placeBall" || matchData.turnType == "touchback")) {
            stepArray = defineStep(player.xpos, player.ypos);
        }
        if (stepArray.length > 0 && stepStack.length == 0) {
            // Valid step involving this player (block, pass...)
            for (var i = 0; i < stepArray.length; i++) {
                addStepToStack(stepArray[i]);
            }
        } else if (isTurn(player)) {
            selectPlayer(player);
        }
    }
}

var selectPlayer = function(player) {
    // Select a new player.
    if (player == null) {
        return;
    }
    selected = player;
    d3.selectAll(".player").classed("selected", false);
    d3.select("#" + playerId(player)).classed("selected", true);
    updateInfoBox("infoBoxSelected", player);
    if (player.down) {
        if (d3.select("#standUpButton")[0][0] == null) {
            addButtonToColumn({
                label: "Stand Up",
                data: null,
                func: standUp,
                cl: "",
                id: "standUpButton",
                group: 2
            });
            d3.select("#standUpButton").classed("inactive", true);
        }
    } else {
        removeButtonFromColumn("standUpButton");
    }
    setAction(null, selected.action);
}

// Make the circles that represent the players
var drawPlayers = function() {
    for (var i = 0; i < players.length; i++) {
        if (players[i].onPitch) {
            drawPlayer(players[i], gPitch);
        } else {
            drawPlayer(players[i], svgBottom);
        }
    }
}
drawPlayers();

var drawBall = function() {
    gPitch.append("circle")
        .attr("cx", cxBall())
        .attr("cy", cyBall())
        .attr("r", 0.2*viewData.squareSize)
        .attr("class", "ball")
        .attr("id", "ball")
    viewData.nBallTransition = 0;
    viewData.ballTransition = null;
}

if (matchData.xBall != null && matchData.yBall != null) {
    drawBall();
}

// Add knockDown or stunned symbols as necessary, and mark players that have finished their turn
for (var index = 0; index < players.length; index++) {
    var player = players[index];
    if (player.onPitch && player.down) {
        createKnockDownSymbol(player.xpos, player.ypos, player.stunned);
    }
    if (player.onPitch && player.finishedAction) {
        d3.select("#" + playerId(player)).classed("finishedAction", true);
    }
}

// Make a background for selecting options
var optionsWindow = gPitch.append("rect")
    .attr("id", "optionsWindow")
    .attr("x", 0.4 * nSquaresX * viewData.squareSize + viewData.margin)
    .attr("y", 0.4 * nSquaresY * viewData.squareSize + viewData.margin)
    .attr("width", 0.2 * nSquaresX * viewData.squareSize)
    .attr("height", 0.2 * nSquaresY * viewData.squareSize)
    .style("visibility", "hidden");
var optionsForeignObject = gPitch.append("foreignObject")
    .attr("id", "optionsForeignObject")
    .attr("x", 0.4 * nSquaresX * viewData.squareSize + 2*viewData.margin)
    .attr("y", 0.4 * nSquaresY * viewData.squareSize + 2*viewData.margin)
    .attr("width", 0.2 * nSquaresX * viewData.squareSize - 2*viewData.margin)
    .attr("height", viewData.height - (0.4 * nSquaresY * viewData.squareSize + 2*viewData.margin))
    .style("visibility", "hidden");
var optionsHtml = optionsForeignObject.append("xhtml:body")
    .attr("id", "optionsHtml")
    .html("");

var clearSelection = function() {
    selected = null;
    d3.select(".player.selected").classed("selected", false);
    updateInfoBox("infoBoxSelected", null);
    setAction(null, "");
}

var processNextStep = function() {
    if (stepStack.length != 0) {
        processStep(stepStack[0]);
    }
}

var processStep = function(step) {
    console.log("Processing step: ", step);
    if (step != null) {
        if (selected != null && selected.action == "") {
            setAction(selected, selectedAction);
        }
        var stepType = (step.stepType == "reroll") ? step.rerollStepType : step.stepType;
        switch (stepType) {
        case "move":
            processMove(step);
            break;
        case "block":
            processBlock(step);
            break;
        case "push":
            selectPush(step);
            break;
        case "followUp":
            processFollowUp(step);
            break;
        case "knockDown":
            processKnockDown(step);
            break;
        case "standUp":
            processStandUp(step);
            break;
        case "pickUp":
            processPickUp(step);
            break;
        case "scatter":
            processScatter(step);
            break;
        case "catch":
            processCatch(step);
            break;
        case "pass":
            processPass(step);
            break;
        case "throwin":
            processThrowin(step);
            break;
        case "foul":
            processFoul(step);
            break;
        case "handOff":
            processHandOff(step);
            break;
        case "goForIt":
            processGoForIt(step);
            break;
        case "endTurn":
            processEndTurn(step);
            break;
        case "setKickoff":
            processSetKickoff(step);
            break;
        case "placeBall":
            processPlaceBall(step);
            break;
        case "placePlayer":
            processPlacePlayer(step);
            break;
        case "submitBall":
            processSubmitBall(step);
            break;
        case "submitPlayers":
            processSubmitPlayers(step);
            break;
        case "touchback":
            processTouchback(step);
            break;
        case "submitTouchback":
            processSubmitTouchback(step);
            break;
        case "endKickoff":
            processEndKickoff(step);
            break;
        }
    }
}

var processMove = function(step) {
    // Move the player object
    var player = findPlayer(step.side, step.num);
    movePlayer(player, step.x1, step.y1);
    if (step.stepType == "move") {
        player.moveLeft -= 1;
        if (player.moveLeft == -2) {
            finishAction(player);
        }
        if (player == selected) {
            updateInfoBox("infoBoxSelected", player);
        }
    }
    // Tell the server
    postStep(step);
    if (!step.dodge) {
        var data1 = {};
        data1.step = step;
        data1.result = {"success": true};
        var data = {"data": data1};
        postProcessMove(data);
    }
}

var processBlock = function(step) {
    var player = playerInPos(step.x0, step.y0);
    if (step.action == "blitz") {
        player.moveLeft -= 1;
        if (player == selected) {
            updateInfoBox("infoBoxSelected", player);
        }
    }
    if (player.moveLeft == -2 || step.action != "blitz") {
        finishAction(player);
    }
    postStep(step);
}

var processPush = function(step) {
    // Tell the server
    postStep(step);
    // Check if they're being pushed into someone else
    var nextPlayer = playerInPos(step.x1, step.y1);
    // Move the player object
    var player = findPlayer(step.side, step.num);
    movePlayer(player, step.x1, step.y1, step.offPitch);
    if (player.hasBall) {
        var possibleTouchdown = true;
        for (var index = 0; index < stepStack.length; index++) {
            if (stepStack[index].stepType == "knockDown" && stepStack[index].side == player.side && stepStack[index].num == player.num) {
                possibleTouchdown = false;
            }
            if (possibleTouchdown) {
                checkForTouchdown(player);
            }
        }
    }
    if (nextPlayer != null) {
        // Push the next player too
        step.targetSide = nextPlayer.side;
        step.targetNum = nextPlayer.num;
        var nextStep = definePush(step);
        stepStack[0] = nextStep;
    } else if (!player.hasBall && ballInPos(step.x1, step.y1)) {
        // The ball scatters away if you're pushed into it
        var nextStep = defineScatter(1);
        stepStack[0] = nextStep;
    } else if (player.hasBall && step.offPitch) {
        var nextStep = defineThrowin(step.x0, step.y0);
        stepStack[0] = nextStep;
        if (isTurn(player)) {
            addStepToStack(defineTurnover());
        }
    } else {
        stepStack.shift();    
    }
    if (!step.offPitch) {
        processNextStep();
    }
}

var processFollowUp = function(step) {
    switch (step.choice) {
    case true:
        processMove(step);
        break;
    case false:
        postStep(step);
        stepStack.shift();
        processNextStep();
        break;
    case null:
        selectFollowUp(step);
        break;
    }
}

var processKnockDown = function(step) {
    var player = findPlayer(step.side, step.num);
    if (player.onPitch) {
        player.down = true;
        createKnockDownSymbol(player.xpos, player.ypos, false);
        if (isTurn(player)) {
            addStepToStack(defineTurnover());
        }
        postStep(step);
    } else {
        // The player must have just been pushed off the pitch
        stepStack.shift();
        processNextStep();
    }
}

var processStandUp = function(step) {
    var player = findPlayer(step.side, step.num);
    player.moveLeft -= 3;
    if (player == selected) {
        updateInfoBox("infoBoxSelected", player);
    }
    if (player.moveLeft <= -2) {
        finishAction(player);
    }
    postStep(step);
}

var processPickUp = function(step) {
    postStep(step);
}

var processScatter = function(step) {
    postStep(step);
}

var processCatch = function(step) {
    postStep(step);
}

var processPass = function(step) {
    var player = playerInPos(step.x0, step.y0);
    finishAction(player);
    postStep(step);
}

var processThrowin = function(step) {
    postStep(step);
}

var processFoul = function(step) {
    var player = playerInPos(step.x0, step.y0);
    finishAction(player);
    postStep(step);
}

var processHandOff = function(step) {
    var player = findPlayer(step.side, step.num);
    finishAction(player);
    player.hasBall = false;
    moveBall(step.x1, step.y1);
    postStep(step);
    var receivingPlayer = playerInPos(step.x1, step.y1);
    var nextStep = defineCatch(receivingPlayer, true, true);
    stepStack[0] = nextStep;
    processNextStep();
}

var processGoForIt = function(step) {
    postStep(step);
}

var processEndTurn = function(step) {
    var messageArray = [];
    clearSelection();
    matchData.homeRerollUsedThisTurn = false;
    matchData.awayRerollUsedThisTurn = false;
    if (matchData.homeRerolls > 0) {
        d3.select("#homeRerolls")
            .classed("home", true)
            .classed("rerollUsed", false);
    }
    if (matchData.awayRerolls > 0) {
        d3.select("#awayRerolls")
            .classed("away", true)
            .classed("rerollUsed", false);
    }
    if (step.turnover) {
        messageArray[messageArray.length] = "Turnover!"
    }
    var skipTurn = false;
    if (step.touchdown) {
        matchData[step.side+"Score"] += 1;
        d3.select("#"+step.side+"Score").text(matchData[step.side+"Score"]);
        if (step.side != matchData.currentSide) {
            skipTurn = true;
        }
        matchData.currentSide = step.side;
        messageArray[messageArray.length] = "Touchdown!";
    } else {
        matchData.currentSide = otherSide(matchData.currentSide);
    }
    for (var i = 0; i < players.length; i++) {
        players[i].moveLeft = players[i].ma;
        players[i].action = "";
        players[i].finishedAction = false;
        if (isTurn(players[i]) && players[i].stunned && !players[i].stunnedThisTurn) {
            players[i].stunned = false;
            d3.select("#"+playerId(players[i])+"stunned").data([]).exit().remove();
            createKnockDownSymbol(players[i].xpos, players[i].ypos, false)
        }
        players[i].stunnedThisTurn = false;
        gPitch.selectAll(".player").classed("finishedAction", false);
    }
    var endOfHalf = false;
    if ((matchData.firstKickingTeam != matchData.currentSide && matchData.turnNumber <= 8) || (matchData.firstKickingTeam == matchData.currentSide && matchData.turnNumber >= 9) || skipTurn) {
        matchData.turnNumber += 1;
        if (matchData.turnNumber == 9) {
            matchData.homeRerolls = matchData.homeRerollsTotal;
            matchData.awayRerolls = matchData.awayRerollsTotal;
            addStepToStack({stepType: "setKickoff", action: "setKickoff", kickingTeam: otherSide(matchData.firstKickingTeam)});
            // setKickoff(otherSide(matchData.firstKickingTeam));
            messageArray[messageArray.length] = "Second half";
            endOfHalf = true;
        } else if (matchData.turnNumber == 17) {
            endMatch();
            var message;
            if (currentLeader() == null) {
                message = "Draw!";
            } else {
                message = teamName(currentLeader()) + " win!";
            }
            messageArray[messageArray.length] = message;
            endOfHalf = true;
        }
    }
    updateTurnIndicator();
    if (step.touchdown && !endOfHalf) {
        addStepToStack({stepType: "setKickoff", action: "setKickoff", kickingTeam: step.side})
        // setKickoff(step.side);
    }
    stepStack = [];
    setAction(null, "");
    if (messageArray.length > 0) {
        displayMessage(messageArray, null, function(){postStep(step);});
    } else {
        postStep(step);
    }
}

var processSetKickoff = function(step) {
    postStep(step);
}

var processPlaceBall = function(step) {
    moveBall(step.x1, step.y1);
    postStep(step);
    stepStack.shift();
    processNextStep();
}

var processPlacePlayer = function(step) {
    var player = findPlayer(step.side, step.num);
    if (step.subs) {
        if (player.onPitch) {
            removeFromPitch(player);
        }
    } else {
        movePlayer(player, step.x1, step.y1);
    }
    postStep(step);
    stepStack.shift();
    processNextStep();    
}

var processSubmitBall = function(step) {
    postStep(step);
    return;
}

var processSubmitPlayers = function(step) {
    clearSelection();
    matchData.nToPlace -= 1;
    if (matchData.nToPlace == 0) {
        matchData.turnType = "placeBall";
        selectedAction = "placeBall";
        viewData.buttonData = defineButtonData("placeBall");
        refreshButtonColumn();
    }
    matchData.currentSide = otherSide(matchData.currentSide);
    updateTurnIndicator();
    postStep(step);
    stepStack = [];
    return;
}

var processTouchback = function(step) {
    moveBall(step.x1, step.y1);
    playerInPos(step.x1, step.y1).hasBall = true;
    postStep(step);
    stepStack.shift();
    processNextStep();
}

var processSubmitTouchback = function(step) {
    postStep(step);
    stepStack = [];
}

var processEndKickoff = function(step) {
    postStep(step);
    stepStack = [];
}

var removeFromPitch = function(player, reason) {
    player.onPitch = false;
    d3.select("#"+playerId(player)).transition().style("opacity", 0).remove();
    d3.select("#"+playerId(player)+"knockDown").transition().style("opacity", 0).remove();
    d3.select("#"+playerId(player)+"stunned").transition().style("opacity", 0).remove();
    if (reason == "knockedOut") {
        player.knockedOut = true;
    } else if (reason == "casualty") {
        player.casualty = true;
    } else if (reason == "sentOff") {
        player.sentOff = true;
    }
    if (player === selected) {
        clearSelection();
    }
    // Draw the player again on the bench.
    drawPlayer(player, svgBottom);
}

var postStep = function(step) {
    // Tell the server about the move
    if (step.historyPosition == null) {
        step.historyPosition = history.length;
        history[step.historyPosition] = step;
    }
    step.matchId = matchData.id;
    console.log("Sending move " + step.historyPosition + " to server");
    console.log(step);
    $.ajax({
        type: "POST",
        url: "/game/post_step", 
        data: step,
        dataType: "json",
        success: function(result) {
            console.log(step.historyPosition + ": Result");
            console.log(result)
            switch (result.status)
            {
                case "duplicate":
                    console.log(step.historyPosition + ": Duplicate step")
                    break;
                case "resend":
                    console.log(step.historyPosition + ": Resend step")
                    var index;
                    for (index = result.start; index <= step.historyPosition; index++) {
                        postStep(history[index]);
                    }
                    break;
                case 0:
                    console.log(step.historyPosition + ": OK")
                    step.result = result;
                    postProcessStep(step, result);
                    break;
                case "wrongUser":
                    alert("Wrong user!");
                    break;
                default:
                    console.log("Unrecognised status: " + result.status + " for step " + step.historyPosition);
                    break;
            }
        },
        error: function(jqxhr, textStatus, errorThrown) {
            console.log("Error received for step " + step.historyPosition);
            restoreTo(step.historyPosition - 1);
        }
    });    
}

var postProcessStep = function(step, result) {
    var stepType = (step.stepType == "reroll") ? step.rerollStepType : step.stepType;
    switch (stepType) {
    case "move":
        if (step.dodge) {
            confirmResult(step, result, "Dodge", postProcessMove);
        }
        break;
    case "block":
        if (step.selectedDice == null) {
            var message = "Attack strength: " + result.attackSt;
            message = message + "<br/>Defence strength: " + result.defenceSt;
            message = message + "<br/>Which block dice would you like to use?";
            var teamReroll = (teamRerollAvailable(step.side) && step.stepType != "reroll") ? "active" : "inactive";
            var data = {"step": step, "result": result}
            var labels = [];
            for (var i = 0; i < result.dice.length; i++) {
                if (result.dice[i] == "attackerDown") {
                    labels[i] = "Attacker down";
                } else if (result.dice[i] == "bothDown") {
                    labels[i] = "Both down";
                } else if (result.dice[i] == "pushed") {
                    labels[i] = "Pushed";
                } else if (result.dice[i] == "defenderStumbles") {
                    labels[i] = "Defender stumbles";
                } else if (result.dice[i] == "defenderDown") {
                    labels[i] = "Defender down";
                }
            }
            selectFromOptions(result.dice, message, data, blockDice, teamReroll, false, false, null, labels);
        }
        break;
    case "knockDown":
        var data = {"step": step, "result": result};
        var message = "Armour roll: ";
        if (result.armourRoll.success) {
            message = message + "Success!<br/>Injury roll: " + result.injuryRoll.result;
        } else {
            message = message + "Failed!";
        }
        displayMessage(message, data, postProcessKnockDown);        
        break;
    case "standUp":
        if (result.success) {
            var player = findPlayer(step.side, step.num);
            player.down = false;
            d3.select("#"+playerId(player)+"knockDown")
                .data([]).exit().remove();
        }
        stepStack.shift();
        processNextStep();
        break;
    case "pickUp":
        confirmResult(step, result, "Sure Hands", postProcessPickUp);
        break;
    case "scatter":
        scatterBall(step, result);
        break;
    case "catch":
        confirmResult(step, result, "Catch", postProcessCatch);
        break;
    case "pass":
        confirmResult(step, result, "Pass", postProcessPass);
        break;
    case "throwin":
        scatterBall(step, result);
        break;
    case "push":
        if (step.offPitch) {
            if (result.injuryRoll.result == "knockedOut") {
                player.knockedOut = true;
            } else if (result.injuryRoll.result == "casualty") {
                player.casualty = true;
            }
            displayMessage(result.injuryRoll.result, null, function(d) {processNextStep();})
        }
        break;
    case "foul":
        if (result.armourRoll.success) {
            var victim = playerInPos(step.x1, step.y1);
            if (result.injuryRoll.result == "stunned") {
                victim.stunned = true;
                victim.stunnedThisTurn = true;
                d3.select("#"+playerId(victim)+"knockDown")
                    .data([]).exit().remove();
                createKnockDownSymbol(victim.xpos, victim.ypos, true);
            } else {
                removeFromPitch(victim, result.injuryRoll.result);
            }        
        }
        if (result.sentOff) {
            var player = findPlayer(step.side, step.num);
            removeFromPitch(player, "sentOff");
            player.sentOff = true;
            addStepToStack(defineTurnover());
        }
        var message = "Armour roll: ";
        if (result.armourRoll.success) {
            message = message + "Success!<br/>Injury roll: " + result.injuryRoll.result;
        } else {
            message = message + "Failed!";
        }
        if (result.sentOff) {
            message = message + "<br/>Sent off!";
        }
        stepStack.shift();
        displayMessage(message, null, function(d) {processNextStep();});
        break;
    case "goForIt":
        confirmResult(step, result, null, postProcessGoForIt);
        break;
    case "endTurn":
        break;
    case "setKickoff":
        stepStack.shift();
        if (result.revived.length + result.knockedOut.length > 0) {
            var message = "";
            var player;
            if (result.revived.length > 0) {
                message = message + "Revived:"
                for (var index = 0; index < result.revived.length; index++) {
                    player = findPlayer(result.revived[index].side, result.revived[index].num);
                    d3.select("#"+playerId(player)).transition().style("opacity", 0).remove();
                    drawPlayer(player, svgBottom);
                    player.knockedOut = false;
                    message = message + "<br/>" + player.name;
                }
                if (result.knockedOut.length > 0) { message = message + "<br/>"; }
            }
            if (result.knockedOut.length > 0) {
                message = message + "Still out:"
                for (var index = 0; index < result.knockedOut.length; index++) {
                    player = findPlayer(result.knockedOut[index].side, result.knockedOut[index].num);
                    message = message + "<br/>" + player.name;
                }
            }
            displayMessage(message, null, function(d) {setKickoff(step.kickingTeam);});
        } else {
            setKickoff(step.kickingTeam);
        }
        break;
    case "submitBall":
        scatterBall(step, result);
        break;
    case "submitTouchback":
        endKickoff(true);
        break;
    }
}

var postProcessPickUp = function(data) {
    if (data.data.result.success) {
        var player = findPlayer(data.data.step.side, data.data.step.num);
        player.hasBall = true;
        checkForTouchdown(player);
        stepStack.shift();
    } else {
        var nextStep = defineScatter(1);
        stepStack[0] = nextStep;
        addStepToStack(defineTurnover());
    }
    processNextStep();
}

var postProcessCatch = function(data) {
    var step = data.data.step;
    if (data.data.result.success) {
        var player = findPlayer(step.side, step.num);
        player.hasBall = true;
        checkForTouchdown(player);
        stepStack.shift();
    } else {
        var nextStep = defineScatter(1, false, step.potentialTurnover);
        stepStack[0] = nextStep;
    }
    processNextStep();
}

var postProcessPass = function(data) {
    var step = data.data.step;
    var result = data.data.result;
    var player = findPlayer(step.side, step.num);
    player.hasBall = false;
    var nextStep;
    if (result.success) {
        moveBall(result.x1, result.y1);
        var receivingPlayer = playerInPos(result.x1, result.y1);
        if (receivingPlayer != null) {
            nextStep = defineCatch(receivingPlayer, true, true);
        } else {
            nextStep = defineScatter(1, false, true);
        }
    } else if (result.fumble) {
        nextStep = defineScatter(1);
        addStepToStack(defineTurnover());
    } else {
        moveBall(result.x1, result.y1);
        nextStep = defineScatter(3, true, true);
    }
    stepStack[0] = nextStep;
    processNextStep();
}

var postProcessMove = function(data) {
    var step = data.data.step;
    var result = data.data.result;
    var player = playerInPos(step.x1, step.y1);
    if (result.success) {
        if (player.hasBall) {
            checkForTouchdown(player);
        }
        if (!player.hasBall && ballInPos(step.x1, step.y1)) {
            // Automatically attempt to pick up the ball
            var nextStep = definePickUp(player);
            stepStack[0] = nextStep;
        } else {
            stepStack.shift();    
        }
    } else {
        var nextStep = defineFall(player);
        stepStack[0] = nextStep;
    }
    processNextStep();
}

var postProcessKnockDown = function(data) {
    var step = data.data.step;
    var result = data.data.result;
    var player = findPlayer(step.side, step.num);
    if (result.armourRoll.success) {
        if (result.injuryRoll.result == "stunned") {
            player.stunned = true;
            player.stunnedThisTurn = true;
            d3.select("#"+playerId(player)+"knockDown")
                .data([]).exit().remove();
            createKnockDownSymbol(player.xpos, player.ypos, true);
        } else {
            removeFromPitch(player, result.injuryRoll.result);
        }
    }
    if (player.hasBall) {
        player.hasBall = false;
    }
    if (ballInPos(player.xpos, player.ypos)) {
        var nextStep = defineScatter(1);
        stepStack[0] = nextStep;
    } else {
        stepStack.shift();
    }
    processNextStep();
}

var postProcessGoForIt = function(data) {
    var step = data.data.step;
    var result = data.data.result;
    // Remove the goForIt step from the stack
    stepStack.shift()
    if (!result.success) {
        if (stepStack[0].stepType == "move") {
            // Make sure they can't fall over twice
            stepStack[0].dodge = false;
        } else {
            // Remove the following step
            stepStack.shift();
        }
        var player = findPlayer(step.side, step.num);
        var nextStep = defineFall(player);
        addStepToStack(nextStep);
    }
    processNextStep();
}

var restoreTo = function(restorePosition) {
    console.log("Restoring to " + restorePosition);
    var position;
    for (position = history.length - 1; position > restorePosition; position--) {
        console.log("Removing history item " + position);
        step = history[position];
        switch (step.stepType) {
        case "move":
            var index;
            for (index = 0; index < players.length; index++) {
                if (players[index].side == step.side &&
                    players[index].num == step.num) {
                    var player = players[index];
                    break;
                }
            }
            movePlayer(player, step.x0, step.y0);
            break;
        }
        history.splice(-1, 1);
    }
}

var isTurn = function(player) {
    return player.side == matchData.currentSide;
}

var usedSkillThisTurn = function(player, skill) {
    // Check to see if a particular skill has been used by the player this turn.
    for (var index = history.length-1; index >= 0; index--) {
        if (history[index].stepType == "endTurn" || history[index].side != player.side || history[index].num != player.num) {
            return false;
        }
        if (history[index].stepType == "reroll" && history[index].rerollType == "skill" && history[index].rerollSkill == skill) {
            return true;
        }
    }
    return false;
}

var usedActionThisTurn = function(action) {
    // Check to see if a particular action has been used this turn.
    for (var index = history.length-1; index >= 0; index--) {
        if (history[index].stepType == "endTurn") {
            return false;
        }
        if (history[index].action == action) {
            return true;
        }
    }
    return false;
}

var performedStepThisTurn = function(player, stepType) {
    // Check to see if the player has performed a particular step this turn.
    for (var index = history.length-1; index >= 0; index--) {
        if (history[index].stepType == "endTurn") {
            return false;
        }
        if (history[index].stepType == stepType) {
            return true;
        }
    }
}

var lastActivePlayer = function() {
    var activeSteps = ["move", "block", "standUp", "pass", "foul", "handOff"];
    var step;
    for (var index = history.length-1; index >= 0; index--) {
        step = history[index];
        if (step.stepType == "endTurn") {
            return null;
        }
        for (var j = 0; j < activeSteps.length; j++) {
            if (step.stepType == activeSteps[j]) {
                return findPlayer(step.side, step.num);
            }
        }
    }
    return null;
}

var isAdjacent = function(xpos0, ypos0, xpos1, ypos1) {
    return (Math.abs(xpos0 - xpos1) <= 1 && Math.abs(ypos0 - ypos1) <= 1)
}

var defineStep = function(xpos, ypos) {
    if ((matchData.turnType != "placeBall" && matchData.turnType != "touchback") && (selected == null || selected.finishedAction || selected.down)) {
        return [];
    }
    var step = {};
    switch(selectedAction) {
    case "move":
        if (selected.moveLeft > -2 && playerInPos(xpos, ypos) == null && isAdjacent(xpos, ypos, selected.xpos, selected.ypos)) {
            step.stepType = "move";
            step.dodge = (nTackleZones(selected) > 0);
            step.goForIt = (selected.moveLeft <= 0);
        } else {
            step = null;
        }
        break;
    case "block":
        var targetPlayer = playerInPos(xpos, ypos);
        if (targetPlayer != null && targetPlayer.side != selected.side && isAdjacent(xpos, ypos, selected.xpos, selected.ypos) && !targetPlayer.down) {
            step.stepType = "block";
            step.targetNum = targetPlayer.num;
            step.targetSide = targetPlayer.side;
        } else {
            step = null;
        }
        break;
    case "blitz":
        if (selected.moveLeft > -2 && isAdjacent(xpos, ypos, selected.xpos, selected.ypos)) {
            var targetPlayer = playerInPos(xpos, ypos);
            if (targetPlayer == null) {
                step.stepType = "move";
                step.dodge = (nTackleZones(selected) > 0);
                step.goForIt = (selected.moveLeft <= 0);
            } else if (targetPlayer.side != selected.side && !targetPlayer.down && !performedStepThisTurn(selected, "block")) {
                step.stepType = "block";
                step.targetNum = targetPlayer.num;
                step.targetSide = targetPlayer.side;
                step.goForIt = (selected.moveLeft <= 0);
            } else {
                step = null;
            }
        } else {
            step = null;
        }
        break;
    case "pass":
        var targetPlayer = playerInPos(xpos, ypos);
        if (selected.moveLeft > -2 && targetPlayer == null && isAdjacent(xpos, ypos, selected.xpos, selected.ypos)) {
            step.stepType = "move";
            step.dodge = (nTackleZones(selected) > 0);
            step.goForIt = (selected.moveLeft <= 0);
        } else if (inPassRange(xpos, ypos) && selected.hasBall) {
            step.stepType = "pass";
        } else {
            step = null;
        }
        break;
    case "handOff":
        if (isAdjacent(xpos, ypos, selected.xpos, selected.ypos)) {
            var targetPlayer = playerInPos(xpos, ypos);
            if (targetPlayer == null) {
                if (selected.moveLeft > -2) {
                    step.stepType = "move";
                    step.dodge = (nTackleZones(selected) > 0);
                    step.goForIt = (selected.moveLeft <= 0);
                } else {
                    step = null;
                }
            } else if (selected.hasBall) {
                step.stepType = "handOff";
            } else {
                step = null;
            }
        } else {
            step = null;
        }
        break;
    case "foul":
        if (isAdjacent(xpos, ypos, selected.xpos, selected.ypos)) {
            var targetPlayer = playerInPos(xpos, ypos);
            if (targetPlayer == null) {
                if (selected.moveLeft > -2) {
                    step.stepType = "move";
                    step.dodge = (nTackleZones(selected) > 0);
                    step.goForIt = (selected.moveLeft <= 0);
                } else {
                    step = null;
                }
            } else if (targetPlayer.side != selected.side && targetPlayer.down) {
                step.stepType = "foul";
                step.targetNum = targetPlayer.num;
                step.targetSide = targetPlayer.side;
            } else {
                step = null;
            }
        } else {
            step = null;
        }
        break;
    case "placeBall":
        var expectedHalf;
        if ((matchData.kickingTeam == "home" && matchData.turnNumber <= 8) || (matchData.kickingTeam == "away" && matchData.turnNumber >= 9)) {
            expectedHalf = matchData.homeFirstDirection;
        } else {
            expectedHalf = (matchData.homeFirstDirection == "right") ? "left" : "right";
        }
        if ((expectedHalf == "left" && xpos < 13) || (expectedHalf == "right" && xpos >= 13)) {
            step.stepType = "placeBall";
            step.bounceAgain = true;
        } else {
            step = null;
        }
        break;
    case "placePlayer":
        if (playerInPos(xpos, ypos) == null) {
            var expectedHalf;
            if ((selected.side == "home" && matchData.turnNumber <= 8) || (selected.side == "away" && matchData.turnNumber >= 9)) {
                expectedHalf = (matchData.homeFirstDirection == "right") ? "left" : "right";
            } else {
                expectedHalf = matchData.homeFirstDirection;
            }
            if ((expectedHalf == "left" && xpos < 13) || (expectedHalf == "right" && xpos >= 13)) {
                step.stepType = "placePlayer";
            } else {
                step = null;
            }
        } else {
            step = null;
        }
        break;
    case "touchback":
        var player = playerInPos(xpos, ypos);
        if (player != null && player.side == matchData.currentSide) {
            step.stepType = "touchback";
            step.side = player.side;
            step.num = player.num;
        } else {
            step = null;
        }
        break;
    default:
        step = null;
    }
    var stepArray = [];
    if (step != null) {
        if (step.goForIt) {
            stepArray[0] = {"stepType": "goForIt"};
        }
        stepArray[stepArray.length] = step;
        for (var i = 0; i < stepArray.length; i++) {
            stepArray[i].action = selectedAction;
            if (step.stepType != "placeBall" && step.stepType != "touchback") {
                stepArray[i].side = selected.side;
                stepArray[i].num = selected.num;
                stepArray[i].x0 = selected.xpos;
                stepArray[i].y0 = selected.ypos;
            }
            stepArray[i].x1 = xpos;
            stepArray[i].y1 = ypos;            
        }
    }
    return stepArray;
}

var defineKnockDown = function(step, dice, victim) {
    var newStep = {}
    newStep.action = selectedAction;
    newStep.stepType = "knockDown";
    if (victim == "defender") {
        newStep.num = step.targetNum;
        newStep.side = otherSide(step.side);
    } else {
        newStep.num = step.num;
        newStep.side = step.side;
    }
    var player = findPlayer(newStep.side, newStep.num);
    if ((dice == "bothDown" && hasSkill(player, "Block")) || (dice == "defenderStumbles" && hasSkill(player, "Dodge")) || !player.onPitch) {
        // Avoid a Both Down result with the block skill, or a Defender Stumbles with the dodge skill. Do nothing if the player has been pushed off the pitch.
        return null;
    } else {
        return newStep;
    }
}

var defineFall = function(player) {
    var step = {};
    step.action = selectedAction;
    step.stepType = "knockDown";
    step.num = player.num;
    step.side = player.side;
    return step;
}

var definePush = function(lastStep) {
    var step = {};
    step.stepType = "push";
    step.action = lastStep.action;
    step.side = lastStep.targetSide;
    step.num = lastStep.targetNum;
    step.x0 = lastStep.x0;
    step.y0 = lastStep.y0;
    step.x1 = lastStep.x1;
    step.y1 = lastStep.y1;
    return step
}

var defineFollowUp = function(blockStep) {
    var step = {};
    step.stepType = "followUp";
    step.targetNum = blockStep.targetNum;
    step.action = blockStep.action;
    step.side = blockStep.side;
    step.num = blockStep.num;
    step.x0 = blockStep.x0;
    step.y0 = blockStep.y0;
    step.x1 = blockStep.x1;
    step.y1 = blockStep.y1;
    step.choice = null;
    return step
}

var definePickUp = function(player) {
    var step = {};
    step.stepType = "pickUp";
    step.side = player.side;
    step.num = player.num;
    step.xpos = player.xpos;
    step.ypos = player.ypos;
    step.action = selectedAction;
    return step;
}

var defineScatter = function(nScatter, bounceAgain, potentialTurnover) {
    bounceAgain = (typeof bounceAgain === "undefined") ? false : bounceAgain;
    potentialTurnover = (typeof potentialTurnover === "undefined") ? false: potentialTurnover;
    var step = {};
    step.stepType = "scatter";
    step.action = selectedAction;
    step.x0 = matchData.xBall;
    step.y0 = matchData.yBall;
    step.nScatter = nScatter;
    step.bounceAgain = bounceAgain;
    step.potentialTurnover = potentialTurnover
    return step;
}

var defineCatch = function(player, accurate, potentialTurnover) {
    var step = {};
    step.stepType = "catch";
    step.side = player.side;
    step.num = player.num;
    step.xpos = player.xpos;
    step.ypos = player.ypos;
    step.accurate = accurate;
    step.action = selectedAction;
    step.potentialTurnover = potentialTurnover;
    return step;
}

var defineThrowin = function(lastX, lastY, potentialTurnover) {
    potentialTurnover = (typeof potentialTurnover === "undefined") ? false: potentialTurnover;
    var step = {};
    step.stepType = "throwin";
    step.lastX = lastX;
    step.lastY = lastY;
    step.bounceAgain = true;
    step.action = selectedAction;
    step.potentialTurnover = potentialTurnover;
    return step;
}

var defineTurnover = function() {
    var step = {
        stepType: "endTurn",
        action: "endTurn",
        oldSide: matchData.currentSide,
        turnover: true
    };
    return step;
}

var selectPush = function(step) {
    var squares = new Array;
    var xB = step.x1 + (step.x1 - step.x0);
    var yB = step.y1 + (step.y1 - step.y0);
    if (playerInPos(xB, yB) == null && onPitch(xB, yB)) {
        squares[squares.length] = [xB, yB];
    }
    var xA, yA, xC, yC;
    if (step.x1 == step.x0) {
        // Up/down push
        xA = xB - 1;
        yA = yB;
        xC = xB + 1;
        yC = yB;
    } else if (step.y1 == step.y0) {
        // Left/right push
        xA = xB;
        yA = yB - 1;
        xC = xB;
        yC = yB + 1;
    } else {
        // Diagonal push
        xA = xB;
        yA = step.y1;
        xC = step.x1;
        yC = yB;
    }
    if (playerInPos(xA, yA) == null && onPitch(xA, yA)) {
        squares[squares.length] = [xA, yA];
    }
    if (playerInPos(xC, yC) == null && onPitch(xC, yC)) {
        squares[squares.length] = [xC, yC];
    }
    if (squares.length == 0 && onPitch(xA, yA) && onPitch(xB, yB) && onPitch(xC, yC)) {
        // Have to push into another player
        squares[0] = [xB, yB];
        squares[1] = [xA, yA];
        squares[2] = [xC, yC];
    }
    if (squares.length > 0) {
        viewData.activityType = "selectPush";
        pitch.on("click", null);
        for (var index = 0; index < squares.length; index++) {
            var xpos = squares[index][0];
            var ypos = squares[index][1];
            gPitch.select("#" + gridId({"xpos": xpos, "ypos": ypos}))
                .classed("gridOption", true)
                .on("click", function(d) {push(step, d.xpos, d.ypos);})
            var player = playerInPos(xpos, ypos);
            if (player != null) {
                gPitch.select("#" + playerId(player))
                    .on("click", function(d) {push(step, d.xpos, d.ypos);})
            }
        }
        pitch.sort(function(a, b) {
            if (gPitch.select("#" + gridId(a)).classed("gridOption")) {
                return 1;
            } else {
                return -1;
            }
        })
    } else {
        // Have to push into the crowd
        var xpos, ypos;
        if (!onPitch(xB, xB)) {
            xpos = xB;
            ypos = yB;
        } else if (!onPitch(xA, xA)) {
            xpos = xA;
            ypos = yA;
        } else {
            xpos = xC;
            ypos = yC;
        }
        displayMessage("Pushed into the crowd!", null, function() {push(step, xpos, ypos);});
    }
}

var confirmResult = function(step, result, rerollSkill, callback) {
    var stepType = (step.stepType == "reroll") ? step.rerollStepType: step.stepType;
    var message;
    if (stepType == "move") { message = "Dodge: "; }
    else if (stepType == "pickUp") { message = "Pick up ball: "; }
    else if (stepType == "catch") { message = "Catch: "; }
    else if (stepType == "pass") { message = "Pass: "; }
    else if (stepType == "goForIt") { message = "Go for it: "; }
    else { message = ""; }
    var teamReroll, skillReroll, proReroll;
    var data = {"step": step, "result": result};
    if (result.success) {
        message = message + "Success!";
        teamReroll = false;
        skillReroll = false;
        proReroll = false;
    } else {
        if (result.fumble) {
            message = message + "Fumbled!";
        } else {
            message = message + "Failed!";
        }
        var player = findPlayer(step.side, step.num);
        teamReroll = (teamRerollAvailable(step.side) && step.stepType != "reroll") ? "active" : "inactive";
        if (rerollSkill != null) {
            skillReroll = (hasSkill(player, rerollSkill) && step.stepType != "reroll" && !(rerollSkill == "Dodge" && usedSkillThisTurn(player, rerollSkill))) ? "active" : "inactive";        
        } else {
            skillReroll = false;
        }
        proReroll = false;
    }
    if (stepType == "move" || stepType == "pickUp" || stepType == "catch" || stepType == "pass") {
        message = message + "<br/>Rolled: " + result.rawResult + "<br/>Modified: " + result.modifiedResult + "<br/>Required: " + result.requiredResult
    } else if (stepType == "goForIt") {
        message = message + "<br/>Rolled: " + result.dice[0];
    }
    selectFromOptions(["OK"], message, data, callback, teamReroll, skillReroll, proReroll, rerollSkill);
}

var selectFollowUp = function(step) {
    var message = "Do you want to follow up?"
    selectFromOptions(["Yes", "No"], message, step, followUp, false, false, false, null);
}

var displayMessage = function(message, data, callback) {
    var thisMessage, nextMessage, func;
    if (typeof message === "object") {
        thisMessage = message[0];
        if (message.length == 1) {
            func = callback;
        } else {
            nextMessage = message;
            nextMessage.shift();
            func = function(){displayMessage(nextMessage, data, callback);};
        }
    } else {
        thisMessage = message;
        func = callback;
    }
    selectFromOptions(["OK"], thisMessage, data, func, false, false, false, null);
}

var selectFromOptions = function(options, message, data, callback, teamReroll, skillReroll, proReroll, rerollSkill, labels) {
    labels = (typeof labels === "undefined") ? options : labels
    viewData.activityType = "selectFromOptions";
    var selectOption = function(d) {
        if (d.inactive) { return; }
        viewData.activityType = "normal";
        gPitch.select("#optionsWindow").style("visibility", "hidden");
        gPitch.select("#optionsForeignObject").style("visibility", "hidden");
        gPitch.selectAll("g.option").data([]).exit().remove();
        if (d.option == "teamReroll") {
            reroll(d, "team", null);
        } else if (d.option == "skillReroll") {
            reroll(d, "skill", rerollSkill);
        } else if (d.option == "proReroll") {
            reroll(d, "pro", null);
        } else {
            callback(d);            
        }
    }
    var optionsData = new Array;
    for (var index = 0; index < options.length; index++) {
        optionsData[index] = {"option": options[index], "data": data, "inactive": false, "label": labels[index]};
    }
    if (teamReroll) {
        optionsData[optionsData.length] = {"option": "teamReroll", "data": data, "inactive": (teamReroll == "inactive"), "label": "Use team re-roll"};
    }
    if (skillReroll) {
        optionsData[optionsData.length] = {"option": "skillReroll", "data": data, "inactive": (skillReroll == "inactive"), "label": "Use skill re-roll"};
    }
    if (proReroll) {
        optionsData[optionsData.length] = {"option": "proReroll", "data": data, "inactive": (proReroll == "inactive"), "label": "Use Pro re-roll"};
    }
    gPitch.select("#optionsWindow").style("visibility", "visible");
    gPitch.select("#optionsForeignObject").style("visibility", "visible");
    gPitch.select("#optionsHtml").html(message);
    var optionsWindowHeight = 3*viewData.margin + $("#optionsHtml").height()+ 1.3*viewData.buttonHeight*optionsData.length;
    var optionsWindowTop = viewData.margin + 0.5*nSquaresY*viewData.squareSize - 0.5*optionsWindowHeight;
    gPitch.select("#optionsWindow")
        .attr("height", optionsWindowHeight)
        .attr("y", optionsWindowTop);
    gPitch.select("#optionsForeignObject")
        .attr("y", optionsWindowTop + viewData.margin)
    var firstButtonTop = $("#optionsHtml").position().top + $("#optionsHtml").height() + viewData.margin;
    var g = gPitch.selectAll("g.option")
        .data(optionsData)
        .enter()
        .append("g")
        .attr("class", "option")
        .classed("inactive", function(d) {return d.inactive})
        .on("click", selectOption);
    g.append("rect")
        .attr("x", 0.5 * nSquaresX * viewData.squareSize + viewData.margin - 0.5 * viewData.buttonWidth)
        .attr("y", function(d, i) { return firstButtonTop + (1.3*i)*viewData.buttonHeight; })
        .attr("width", viewData.buttonWidth)
        .attr("height", viewData.buttonHeight)
        .classed("button", true)
    g.append("text")
        .text(function(d) { return d.label; })
        .attr("x", 0.5 * nSquaresX * viewData.squareSize + viewData.margin)
        .attr("y", function(d, i) { return firstButtonTop + (0.5+1.3*i)*viewData.buttonHeight; })
        .classed("buttonText", true)
}

var blockDice = function(data) {
    var dice = data.option;
    var step = $.extend({}, data.data.step);
    step.stepType = "selectBlockDice";
    step.historyPosition = null;
    step.selectedDice = dice;
    postStep(step);
    var nextStep = null;
    var followingStep = null;
    var thirdStep = null;
    switch (dice) {
    case "attackerDown":
        nextStep = defineKnockDown(step, dice, "attacker");
        break;
    case "bothDown":
        nextStep = defineKnockDown(step, dice, "defender");
        followingStep = defineKnockDown(step, dice, "attacker");
        break;
    case "pushed":
        nextStep = definePush(step);
        followingStep = defineFollowUp(step);
        break;
    case "defenderStumbles":
    case "defenderDown":
        nextStep = definePush(step);
        followingStep = defineFollowUp(step);
        thirdStep = defineKnockDown(step, dice, "defender");
        break;
    }
    stepStack.shift();
    addStepToStack(nextStep);
    addStepToStack(followingStep);
    addStepToStack(thirdStep);
}

var followUp = function(data) {
    // Update the followUp step
    var step = data.data;
    if (data.option == "Yes") {
        step.choice = true;
    } else {
        step.choice = false;
    }
    stepStack[0] = step;
    processNextStep();
}

var push = function(step, xpos, ypos) {
    gPitch.selectAll(".gridOption")
        .classed("gridOption", false)
    viewData.activityType = "normal";
    pitch.on("click", clickPitch);
    var player = findPlayer(step.side, step.num);
    var newStep = {};
    newStep.action = step.action;
    newStep.stepType = "push";
    newStep.side = player.side;
    newStep.num = player.num;
    newStep.x0 = step.x1;
    newStep.y0 = step.y1;
    newStep.x1 = xpos;
    newStep.y1 = ypos;
    newStep.offPitch = !onPitch(xpos, ypos);
    processPush(newStep);
}

var scatterBall = function(step, result) {
    var xpos = result.x1;
    var ypos = result.y1;
    moveBall(xpos, ypos);
    if (matchData.turnType == "placeBall" && (!onPitch(xpos, ypos) || (step.x0 < 13 && result.x1 >= 13) || (step.x0 >= 13 && result.x1 < 13))) {
        matchData.turnType = "touchback";
        selectedAction = "touchback";
        matchData.currentSide = otherSide(matchData.currentSide);
        updateTurnIndicator();
        matchData.xBall = null;
        matchData.yBall = null;
        displayMessage("Touchback!", null, function(){});
        viewData.buttonData = defineButtonData("touchback");
        refreshButtonColumn();
    } else if (!onPitch(xpos, ypos)) {
        var nextStep = defineThrowin(result.lastX, result.lastY, step.potentialTurnover);
        stepStack[0] = nextStep;
    } else {
        var player = playerInPos(xpos, ypos);
        if (player != null) {
            var nextStep = defineCatch(player, false, step.potentialTurnover);
            stepStack[0] = nextStep;
        } else {
            if (step.bounceAgain) {
                var nextStep = defineScatter(1, false, step.potentialTurnover);
                stepStack[0] = nextStep;
            } else if (matchData.turnType == "placeBall") {
                stepStack.shift();
                endKickoff(false);
            } else {
                if (step.potentialTurnover) {
                    addStepToStack(defineTurnover());
                }
                stepStack.shift()
            }
        }
    }
    processNextStep();
}

var otherSide = function(side) {
    if (side == "home") {
        return "away";
    } else if (side == "away") {
        return "home";
    } else {
        console.log("No other side for " + side);
        return null;
    }
}

var moveBall = function(xpos, ypos, destroy) {
    destroy = (typeof destroy === "undefined") ? false : destroy;
    var onPitch = (matchData.xBall != null && matchData.yBall != null);
    matchData.xBall = xpos;
    matchData.yBall = ypos;
    if (onPitch) {
        var base;
        if (viewData.nBallTransition > 0) {
            base = viewData.ballTransition;
        } else {
            base = d3.select("#ball");
        }
        viewData.ballTransition = base.transition()
            .attr("cx", cxBall())
            .attr("cy", cyBall())
            .each("end", function(){viewData.nBallTransition -= 1;});
        viewData.nBallTransition += 1;
        if (destroy) {
            viewData.ballTransition.each("end", function(){d3.select("#ball").data([]).exit().remove();})
        }
    } else {
        drawBall();
    }
}

var movePlayer = function(player, xpos, ypos, destroy) {
    destroy = (typeof destroy === "undefined") ? false : destroy;
    var x0 = player.xpos;
    var y0 = player.ypos;
    var deltaX = viewData.squareSize * (xpos - x0);
    var deltaY = viewData.squareSize * (ypos - y0);
    player.xpos = xpos;
    player.ypos = ypos;
    if (player.onPitch) {
        var symbolId = playerId(player) + "Symbol";
        var numberId = playerId(player) + "Number";
        var symbolTransition = moveShape(symbolId, deltaX, deltaY, player.interpolate);
        var numberTransition = moveText(numberId, deltaX, deltaY)
        if (player.hasBall) {
            // Move the ball too
            moveBall(xpos, ypos);
        }
        if (player.down) {
            // Move their down/stunned symbol
            var id = (player.stunned) ? playerId(player) + "stunned" : playerId(player) + "knockDown";
            moveShape(id, deltaX, deltaY, "linear");
        }
        if (destroy) {
            var playerG = d3.select("#" + playerId(player));
            symbolTransition.each("end", function(){playerG.remove();})
        }
    } else {
        player.onPitch = true;
        d3.select("#"+playerId(player)).transition().style("opacity", 0).remove();
        drawPlayer(player, gPitch);
    }
}

var moveText = function(id, deltaX, deltaY) {
    var text = d3.select("#" + id);
    var x = parseInt(text.attr("x")) + deltaX;
    var y = parseInt(text.attr("y")) + deltaY;
    return text.transition().attr("x", x).attr("y", y);
}

var inPassRange = function(xpos, ypos) {
    var deltaX = Math.abs(xpos - selected.xpos);
    var deltaY = Math.abs(ypos - selected.ypos);
    return ((deltaX <= 1 && deltaY <= 13) || (deltaX <= 4 && deltaY <= 12) || (deltaX <= 6 && deltaY <= 11) || (deltaX <= 8 && deltaY <= 10) || (deltaX == 9 && deltaY <= 9) || (deltaX == 10 && deltaY <= 8) || (deltaX == 11 && deltaY <= 6) || (deltaX == 12 && deltaY <= 4) || (deltaX == 13 && deltaY <= 1));
}

var teamRerollAvailable = function(side) {
    var available;
    if (side == "home") {
        available = (matchData.homeRerolls > 0 && !matchData.homeRerollUsedThisTurn);
    } else if (side == "away") {
        available = (matchData.awayRerolls > 0 && !matchData.awayRerollUsedThisTurn);
    }
    return available;
}

var reroll = function(data, rerollType, rerollSkill) {
    var step = $.extend({}, data.data.step);
    step.rerollStepType = step.stepType;
    step.stepType = "reroll";
    step.rerollType = rerollType;
    if (rerollType == "skill") {
        step.rerollSkill = rerollSkill;
    }
    step.historyPosition = null;
    if (rerollType == "team") {
        if (step.side == "home") {
            matchData.homeRerolls -= 1;
            matchData.homeRerollUsedThisTurn = true;
            d3.select("#homeRerolls")
                .text("Re-rolls: " + matchData.homeRerolls)
                .classed("home", false)
                .classed("rerollUsed", true);
        } else {
            matchData.awayRerolls -= 1;
            matchData.awayRerollUsedThisTurn = true;
            d3.select("#awayRerolls")
                .text("Re-rolls: " + matchData.awayRerolls)
                .classed("away", false)
                .classed("rerollUsed", true);
        }
    }
    stepStack[0] = step;
    processNextStep();
}

var hasSkill = function(player, skill) {
    for (var i = 0; i < player.skills.length; i++) {
        if (player.skills[i] == skill) {
            return true;
        }
    }
    return false;
}

var onPitch = function(xpos, ypos) {
    return (0 <= xpos && xpos < 26 && 0 <= ypos && ypos < 15);
}

var nTackleZones = function(player) {
    var n = 0;
    for (var i = 0; i < players.length; i++) {
        if (isAdjacent(player.xpos, player.ypos, players[i].xpos, players[i].ypos) && player.side != players[i].side && players[i].onPitch && !players[i].down) {
            n += 1;
        }
    }
    return n;
}

var setKickoff = function(kickingTeam) {
    clearSelection();
    d3.selectAll(".knockDownSymbol").data([]).exit().remove();
    d3.selectAll(".stunnedSymbol").data([]).exit().remove();
    var xposHome, xposAway;
    if ((matchData.homeFirstDirection == "right" && matchData.turnNumber <= 8) || (matchData.homeFirstDirection == "left" && matchData.turnNumber >= 9)) {
        xposHome = 0;
        xposAway = 25;
    } else {
        xposHome = 25;
        xposAway = 0;
    }
    var yposHome = 0;
    var yposAway = 0;
    var xpos, ypos, player;
    for (var index = 0; index < players.length; index++) {
        player = players[index];
        if (player.onPitch) {
            player.down = false;
            player.stunned = false;
            player.stunnedThisTurn = false;
            player.hasBall = false;
            player.moveLeft = player.ma;
            player.action = "";
            player.finishedAction = false;
            if (player.side == "home") {
                xpos = xposHome;
                ypos = yposHome;
                yposHome += 1;
            } else {
                xpos = xposAway;
                ypos = yposAway;
                yposAway += 1;
            }
            movePlayer(player, xpos, ypos);
        }
    }
    matchData.nToPlace = 2;
    matchData.kickingTeam = kickingTeam;
    matchData.currentSide = kickingTeam;
    matchData.xBall = null;
    matchData.yBall = null;
    matchData.turnType = "placePlayers";
    selectedAction = "placePlayer";
    d3.select("#ball").data([]).exit().remove();
    viewData.buttonData = defineButtonData(matchData.turnType);
    updateTurnIndicator();
    refreshButtonColumn();
}

var submitPlayerPosition = function() {
    var nScrimmage = 0;
    var nWideUpper = 0;
    var nWideLower = 0;
    var nOnPitch = 0;
    var nAvailable = 0;
    var player;
    for (var i = 0; i < players.length; i++) {
        player = players[i];
        if (player.side == matchData.currentSide && !player.knockedOut && !player.casualty && !player.sentOff) {
            nAvailable += 1;
            if (player.onPitch) {
                nOnPitch += 1;
                if (player.ypos <= 3) {
                    nWideUpper += 1;
                } else if (player.ypos >= 11) {
                    nWideLower += 1;
                } else if (player.xpos == 12 || player.xpos == 13) {
                    nScrimmage += 1;
                }
            }
        }
    }
    var message = null;
    if (nOnPitch > 11) {
        message = "No more than 11 players on the pitch!";
    } else if (nScrimmage < 3 && nScrimmage < nAvailable) {
        message = "At least " + Math.min(nAvailable, 3) + " players on the line of scrimmage!";
    } else if (Math.max(nWideLower, nWideUpper) > 2) {
        message = "No more than 2 players in each wide zone!";
    }
    if (message != null) {
        displayMessage(message, null, function(){});
    } else {
        var step = {action: "placePlayers", stepType: "submitPlayers"};
        addStepToStack(step);
    }
    return;
}

var submitBallPosition = function() {
    if (matchData.xBall != null && matchData.yBall != null) {
        var step = {action: "placeBall", stepType: "submitBall", x0: matchData.xBall, y0: matchData.yBall};
        addStepToStack(step);
    }
    return;
}

var submitTouchback = function() {
    if (matchData.xBall != null && matchData.yBall != null) {
        var step = {action: "touchback", stepType: "submitTouchback"};
        addStepToStack(step);
    }
    return;
}

var endKickoff = function(touchback) {
    stepStack = [];
    matchData.turnType = "normal";
    if (!touchback) {
        matchData.currentSide = otherSide(matchData.currentSide);
        updateTurnIndicator();
    }
    viewData.buttonData = defineButtonData(matchData.turnType);
    refreshButtonColumn();
    processStep({
        stepType: "endKickoff",
        action: "endKickoff",
        touchback: touchback
    });
}

var endMatch = function() {
    matchData.turnType = "end";
    updateTurnIndicator();
    viewData.buttonData = defineButtonData(matchData.turnType);
    refreshButtonColumn();
    gPitch.selectAll(".player").on("click", null);
    pitch.on("click", null);
}

var currentLeader = function() {
    if (matchData.homeScore > matchData.awayScore) {
        return "home";
    } else if (matchData.homeScore < matchData.awayScore) {
        return "away";
    } else {
        return null;
    }
}

var currentCoach = function() {
    return matchData[matchData.currentSide + "Coach"];
}

var teamName = function(side) {
    return matchData[side+"Team"];
}

var checkForTouchdown = function(player) {
    // The player is already known to be holding the ball
    var endZone;
    if ((player.side == "home" && matchData.turnNumber <= 8) || (player.side == "away" && matchData.turnNumber >= 9)) {
        endZone = (matchData.homeFirstDirection == "right") ? 25 : 0;
    } else {
        endZone = (matchData.homeFirstDirection == "right") ? 0 : 25;
    }
    if (player.xpos == endZone) {
        stepStack = [];
        addStepToStack({
            stepType: "endTurn",
            action: "endTurn",
            oldSide: matchData.currentSide,
            touchdown: true,
            side: player.side,
            num: player.num
        });
    }
}

viewData.buttonData = defineButtonData(matchData.turnType);
refreshButtonColumn();

if (matchData.turnType == "normal") {
    selectPlayer(lastActivePlayer());
} else if (matchData.turnType == "touchback") {
    selectedAction = "touchback";
} else if (matchData.turnType == "placeBall") {
    selectedAction = "placeBall";
} else if (matchData.turnType == "placePlayers") {
    selectedAction = "placePlayer";
}

</script>
{% endblock content %}
